# transport_solution.py
import numpy as np
import matplotlib.pyplot as plt

# --- данные задачи ---
V = lambda x: x + 1.0
f = lambda x: -19.1
U0 = lambda x: np.minimum(0.0, (x - 3.0)*(x - 8.0))
g = lambda t: t*(100.0 - t)/2500.0

# --- аналитическое решение в точке (t, x) ---
def U_analytic(t, x):
    # x, t могут быть numpy arrays (broadcastable)
    x = np.asarray(x)
    # используем безопасные вычисления: xi = (x+1) * exp(-t) - 1
    xi = (x + 1.0) * np.exp(-t) - 1.0
    U = np.empty_like(xi, dtype=float)
    # случай: источник из начального условия
    mask_init = xi >= 0
    if np.any(mask_init):
        U[mask_init] = U0(xi[mask_init]) - 19.1 * t
    # случай: источник из граничного условия x=0
    if np.any(~mask_init):
        # s_b = t - ln(x+1)
        sb = t - np.log(x[~mask_init] + 1.0)
        U[~mask_init] = g(sb) - 19.1 * np.log(x[~mask_init] + 1.0)
    return U

# --- явная схема upwind ---
def explicit_upwind(x_grid, t_grid):
    nx = len(x_grid)
    nt = len(t_grid)
    dx = x_grid[1] - x_grid[0]
    dt = t_grid[1] - t_grid[0]
    U = np.zeros((nt, nx))
    # начальное условие
    U[0, :] = U0(x_grid)
    # граничное
    U[:, 0] = g(t_grid)
    # шаги
    for n in range(0, nt-1):
        for i in range(1, nx):
            Vi = V(x_grid[i])
            U[n+1, i] = (U[n, i]
                         - (dt/dx) * Vi * (U[n, i] - U[n, i-1])
                         + dt * f(x_grid[i]))
        # (U[n+1,0] уже задано граничным условием)
    return U

# --- неявная схема upwind (решение треугольной системы) ---
def implicit_upwind(x_grid, t_grid):
    nx = len(x_grid)
    nt = len(t_grid)
    dx = x_grid[1] - x_grid[0]
    dt = t_grid[1] - t_grid[0]
    U = np.zeros((nt, nx))
    U[0, :] = U0(x_grid)
    U[:, 0] = g(t_grid)
    # для каждого временного шага решаем по i прямым ходом
    for n in range(0, nt-1):
        rhs = U[n, :].copy()
        # задать U_{0}^{n+1}
        U[n+1, 0] = g(t_grid[n+1])
        # решаем последовательно i=1..nx-1
        for i in range(1, nx):
            Vi = V(x_grid[i])
            a = 1.0 + (dt/dx) * Vi
            b = - (dt/dx) * Vi  # множитель при U_{i-1}^{n+1}
            # уравнение: a * U_i^{n+1} + b * U_{i-1}^{n+1} = rhs[i] + dt*f(x_i)
            rhs_i = rhs[i] + dt * f(x_grid[i])
            U[n+1, i] = (rhs_i - b * U[n+1, i-1]) / a
    return U

# --- вспомогательная функция RMS ---
def rms_error(U_num, t_grid, x_grid):
    errors = []
    for n, t in enumerate(t_grid):
        U_an = U_analytic(t, x_grid)
        err = np.sqrt(np.mean((U_num[n, :] - U_an)**2))
        errors.append(err)
    return np.array(errors)

# --- пример запуска и визуализации ---
def run_example(dx=0.1, dt_factor=0.9, T=20.0):
    # dx шаг по x
    x = np.arange(0.0, 10.0 + 1e-12, dx)
    # dt, выбираем по CFL для явной: dt = dt_factor * dx / maxV
    maxV = V(10.0)  # 11
    dt = dt_factor * dx / maxV
    t = np.arange(0.0, T + 1e-12, dt)
    print(f"nx={len(x)}, nt={len(t)}, dx={dx:.4g}, dt={dt:.4g}, T={T}")

    U_ex = explicit_upwind(x, t)
    U_im = implicit_upwind(x, t)

    # аналитика в финальный момент
    U_an_final = U_analytic(t[-1], x)

    # RMS по времени
    rms_ex = rms_error(U_ex, t, x)
    rms_im = rms_error(U_im, t, x)

    # график в последний момент
    plt.figure(figsize=(8,5))
    plt.plot(x, U_an_final, label='Аналитическое', linewidth=2)
    plt.plot(x, U_ex[-1,:], '--', label='Явная upwind (числ.)')
    plt.plot(x, U_im[-1,:], ':', label='Неявная upwind (числ.)')
    plt.xlabel('x'); plt.ylabel('U(t,x)'); plt.title(f't={t[-1]:.3f}')
    plt.legend(); plt.grid(True)
    plt.show()

    # RMS по времени
    plt.figure(figsize=(8,4))
    plt.plot(t, rms_ex, label='RMS явной')
    plt.plot(t, rms_im, label='RMS неявной')
    plt.yscale('log')
    plt.xlabel('t'); plt.ylabel('RMS'); plt.legend(); plt.grid(True)
    plt.show()

    return x, t, U_ex, U_im

# Запуск примера
if __name__ == "__main__":
    x, t, U_ex, U_im = run_example(dx=0.2, dt_factor=0.9, T=20.0)
