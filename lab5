import numpy as np
import matplotlib.pyplot as plt

# ----- параметры задачи -----
V = lambda x: x + 1
f_val = -19.1
U0 = lambda x: np.minimum(0, (x - 3) * (x - 8))
Ub = lambda t: t * (100 - t) / 2500

x_min, x_max = 0, 10
t_min, t_max = 0, 100


# Аналитическое решение методом характеристик
def analytical_solution(t, x):
    t = np.atleast_1d(t)
    x = np.atleast_1d(x)
    
    if t.ndim == 1 and x.ndim == 1 and len(t) > 1 and len(x) > 1:
        T, X = np.meshgrid(t, x, indexing='ij')
    else:
        T, X = t, x
    
    U = np.zeros_like(T, dtype=float)
    x0 = (X + 1) * np.exp(-T) - 1
    
    from_initial = (x0 >= 0) & (x0 <= 10)
    U[from_initial] = U0(x0[from_initial]) + f_val * T[from_initial]
    
    from_boundary = ~from_initial
    t0 = T[from_boundary] - np.log(X[from_boundary] + 1)
    valid_t0 = t0 >= 0
    
    U_boundary = np.zeros_like(t0)
    U_boundary[valid_t0] = Ub(t0[valid_t0]) + f_val * (T[from_boundary][valid_t0] - t0[valid_t0])
    U[from_boundary] = U_boundary
    
    return U


# Явная схема (с автоматическим выбором dt для устойчивости)
def explicit_scheme(nx, nt_hint):
    x = np.linspace(x_min, x_max, nx)
    dx = x[1] - x[0]
    
    # Выбираем dt для выполнения CFL < 1
    V_max = V(x_max)  # = 11
    dt_max = 0.9 * dx / V_max  # CFL = 0.9
    nt = max(nt_hint, int((t_max - t_min) / dt_max) + 1)
    
    t = np.linspace(t_min, t_max, nt)
    dt = t[1] - t[0]
    
    U = np.zeros((nt, nx))
    U[0, :] = U0(x)
    Vx = V(x)
    
    for n in range(nt - 1):
        U[n + 1, 0] = Ub(t[n + 1])
        for j in range(1, nx):
            U[n + 1, j] = (
                U[n, j] 
                - dt / dx * Vx[j] * (U[n, j] - U[n, j - 1]) 
                + dt * f_val
            )
    
    return x, t, U, dx, dt


# Неявная схема
def implicit_scheme(nx, nt):
    x = np.linspace(x_min, x_max, nx)
    t = np.linspace(t_min, t_max, nt)
    dx = x[1] - x[0]
    dt = t[1] - t[0]
    
    U = np.zeros((nt, nx))
    U[0, :] = U0(x)
    Vx = V(x)
    
    for n in range(nt - 1):
        U[n + 1, 0] = Ub(t[n + 1])
        for j in range(1, nx):
            coef = dt / dx * Vx[j]
            U[n + 1, j] = (U[n, j] + coef * U[n + 1, j - 1] + dt * f_val) / (1 + coef)
    
    return x, t, U, dx, dt


steps = [
    (50, 500),
    (100, 1000),
    (150, 1500),
    (200, 2000),
    (300, 3000)
]

errors_exp = []
errors_imp = []
results = []

print("\nРасчёт для разных шагов сетки:")
print("-" * 60)

for nx, nt in steps:
    # Явная схема
    x, t, Ue, dx, dt = explicit_scheme(nx, nt)
    Ua = analytical_solution(t, x)
    rmse_exp = np.sqrt(np.mean((Ue - Ua) ** 2))
    errors_exp.append(rmse_exp)
    
    # Неявная схема
    x2, t2, Ui, dx2, dt2 = implicit_scheme(nx, nt)
    Ua2 = analytical_solution(t2, x2)
    rmse_imp = np.sqrt(np.mean((Ui - Ua2) ** 2))
    errors_imp.append(rmse_imp)
    
    results.append((nx, nt, Ue, Ui, Ua2, x2, t2))
    
    print(f"nx={nx:3d}, nt={nt:4d} | dx={dx:.4f} | "
          f"Среднеквадратичное отклонение явн={rmse_exp:.4f}, Среднеквадратичное отклонение неявн={rmse_imp:.4f}")

# ----- визуализация: 5 графиков для каждого варианта сетки -----
fig, axes = plt.subplots(2, 3, figsize=(16, 10))
axes = axes.flatten()

# 5 графиков сравнения решений для каждого варианта сетки
for i, (nx, nt, Ue, Ui, Ua, x, t) in enumerate(results):
    ax = axes[i]
    ax.plot(x, Ua[-1, :], 'k-', linewidth=2, label='Аналитическое')
    ax.plot(x, Ue[-1, :], 'b--', linewidth=1.5, label='Явная схема')
    ax.plot(x, Ui[-1, :], 'r:', linewidth=2, label='Неявная схема')
    ax.set_xlabel('x', fontsize=11)
    ax.set_ylabel('U(t=100, x)', fontsize=11)
    ax.set_title(f'Вариант {i+1}: nx={nx}, nt={nt}\n'
                 f'RMSE явн={errors_exp[i]:.4f}, неявн={errors_imp[i]:.4f}', fontsize=11)
    ax.legend(fontsize=9)
    ax.grid(True, alpha=0.3)

# 6-й график: сходимость схем
axes[5].plot([s[0] for s in steps], errors_exp, 'o-', linewidth=2, markersize=8, label="Явная схема")
axes[5].plot([s[0] for s in steps], errors_imp, 's-', linewidth=2, markersize=8, label="Неявная схема")
axes[5].set_xlabel("Число узлов nx", fontsize=11)
axes[5].set_ylabel("Среднеквадратичное отклонение", fontsize=11)
axes[5].set_title("Сходимость численных схем", fontsize=12)
axes[5].legend(fontsize=10)
axes[5].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print("\nГотово!")
